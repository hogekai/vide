<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>vide — SSAI (Server-Side Ad Insertion)</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 2rem auto; padding: 0 1rem; }
    video { width: 100%; background: #000; display: block; }
    #log { font-family: monospace; font-size: 13px; background: #1a1a1a; color: #0f0; padding: 1rem; max-height: 300px; overflow-y: auto; border-radius: 4px; }
    .log-entry { margin: 2px 0; }
    .log-entry.ad { color: #ff0; }
    .controls { margin: 1rem 0; display: flex; gap: 0.5rem; flex-wrap: wrap; }
    button { padding: 0.4rem 1rem; cursor: pointer; }
    .ad-indicator { display: none; padding: 0.5rem 1rem; background: #e53e3e; color: #fff; font-weight: bold; border-radius: 4px; margin: 0.5rem 0; }
    .ad-indicator.visible { display: block; }
  </style>
  <script type="importmap">
    { "imports": { "hls.js": "https://esm.sh/hls.js@1" } }
  </script>
</head>
<body>
  <h1>vide — SSAI (Server-Side Ad Insertion)</h1>
  <p>
    Fetches a real HLS playlist, injects <code>EXT-X-DATERANGE</code> tags with
    <code>SCTE35-OUT</code> markers, and serves the modified manifest via a
    Blob URL. The SSAI plugin's default parser picks up the DATERANGE
    metadata from hls.js — no custom parser needed.
    Ad breaks: <strong>10s–20s</strong> and <strong>40s–50s</strong>.
  </p>

  <video id="player" controls></video>
  <div id="ad-indicator" class="ad-indicator">AD</div>

  <div class="controls">
    <button onclick="player.play()">Play</button>
    <button onclick="player.pause()">Pause</button>
    <button onclick="player.currentTime = 0">Restart</button>
    <button onclick="player.muted = !player.muted">Toggle Mute</button>
    <button onclick="loadStream()">Load Stream</button>
    <button onclick="player.destroy(); log('destroyed')">Destroy</button>
  </div>

  <h3>State: <span id="state">-</span></h3>
  <div id="log"></div>

  <script type="module">
    import { createPlayer } from "../dist/index.mjs";
    import { hls } from "../dist/hls/index.mjs";
    import { ssai } from "../dist/ssai/index.mjs";

    const el = document.getElementById("player");
    const stateEl = document.getElementById("state");
    const logEl = document.getElementById("log");
    const adIndicator = document.getElementById("ad-indicator");

    function log(msg, isAd = false) {
      const entry = document.createElement("div");
      entry.className = "log-entry" + (isAd ? " ad" : "");
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.prepend(entry);
    }
    window.log = log;

    const player = createPlayer(el);
    window.player = player;

    // Register plugins — no custom parser, the default parseDateRange
    // handles SCTE35-OUT DATERANGE tags automatically.
    player.use(hls());
    player.use(ssai());
    log("HLS + SSAI plugins registered (default SCTE35-OUT parser)");

    // Wire up events
    player.on("statechange", ({ from, to }) => {
      stateEl.textContent = to;
      log(`state: ${from} → ${to}`);
    });
    player.on("play", () => log("event: play"));
    player.on("pause", () => log("event: pause"));
    player.on("ended", () => log("event: ended"));
    player.on("error", ({ code, message }) => log(`error: [${code}] ${message}`));

    // SSAI ad events
    player.on("ad:breakStart", ({ breakId }) => {
      adIndicator.classList.add("visible");
      log(`ad:breakStart — ${breakId}`, true);
    });
    player.on("ad:start", ({ adId }) => log(`ad:start — ${adId}`, true));
    player.on("ad:impression", ({ adId }) => log(`ad:impression — ${adId}`, true));
    player.on("ad:end", ({ adId }) => log(`ad:end — ${adId}`, true));
    player.on("ad:breakEnd", ({ breakId }) => {
      adIndicator.classList.remove("visible");
      log(`ad:breakEnd — ${breakId}`, true);
    });

    log("Player created. State: " + player.state);

    // --- Manifest rewriting ---

    const ORIGIN = "https://test-streams.mux.dev/x36xhzz";
    const MEDIA_PLAYLIST = `${ORIGIN}/url_2/193039199_mp4_h264_aac_ld_7.m3u8`;

    // The epoch anchor for PROGRAM-DATE-TIME. Segment N starts at
    // anchor + N*10s. We use a fixed date so DATERANGE START-DATE
    // values are deterministic.
    const ANCHOR = new Date("2024-01-01T00:00:00Z");

    // Ad breaks defined as { startSec, durationSec }
    const AD_BREAKS = [
      { id: "ad-break-1", startSec: 10, durationSec: 10 },
      { id: "ad-break-2", startSec: 40, durationSec: 10 },
    ];

    /**
     * Fetch the media playlist, rewrite segment URLs to absolute,
     * inject EXT-X-PROGRAM-DATE-TIME + EXT-X-DATERANGE tags, and
     * return a Blob URL that hls.js can load.
     */
    async function buildSsaiPlaylist() {
      const res = await fetch(MEDIA_PLAYLIST);
      const text = await res.text();
      const lines = text.split("\n");

      const out = [];
      let segIndex = 0; // which segment are we on (0-based)

      // Pre-compute DATERANGE lines keyed by segment index
      const daterangeAt = new Map();
      for (const ab of AD_BREAKS) {
        const idx = Math.floor(ab.startSec / 10);
        const startDate = new Date(ANCHOR.getTime() + ab.startSec * 1000);
        const dr =
          `#EXT-X-DATERANGE:ID="${ab.id}",` +
          `START-DATE="${startDate.toISOString()}",` +
          `DURATION=${ab.durationSec},` +
          `SCTE35-OUT=0x0`;
        daterangeAt.set(idx, (daterangeAt.get(idx) ?? []).concat(dr));
      }

      for (const line of lines) {
        // Bump version for DATERANGE support
        if (line.startsWith("#EXT-X-VERSION:")) {
          out.push("#EXT-X-VERSION:7");
          continue;
        }

        // Before each #EXTINF, inject PDT / DATERANGE for this segment
        if (line.startsWith("#EXTINF:")) {
          if (segIndex === 0) {
            out.push(`#EXT-X-PROGRAM-DATE-TIME:${ANCHOR.toISOString()}`);
          }
          const drs = daterangeAt.get(segIndex);
          if (drs) {
            for (const dr of drs) out.push(dr);
          }
          out.push(line);
          segIndex++;
          continue;
        }

        // Rewrite relative segment URLs to absolute
        if (line && !line.startsWith("#")) {
          out.push(new URL(line, MEDIA_PLAYLIST).href);
          continue;
        }

        out.push(line);
      }

      const playlist = out.join("\n");
      log(`Rewritten playlist (${playlist.length} bytes), ${AD_BREAKS.length} DATERANGE tags injected`);

      // Use a Blob URL — hls.js's XHR loader can fetch blob: URIs
      // but not data: URIs. The #.m3u8 fragment hints the HLS plugin
      // that this is an HLS manifest.
      const blob = new Blob([playlist], { type: "application/vnd.apple.mpegurl" });
      return URL.createObjectURL(blob) + "#.m3u8";
    }

    window.loadStream = async function() {
      log("Fetching & rewriting playlist with SCTE35-OUT DATERANGE tags…");
      try {
        const blobUrl = await buildSsaiPlaylist();
        log("Loading blob URL into hls.js…");
        player.src = blobUrl;
        player.once("statechange", ({ to }) => {
          if (to === "ready") {
            player.play().catch(() => {
              player.muted = true;
              player.play().catch(() => {});
            });
          }
        });
      } catch (err) {
        log(`Failed to build playlist: ${err.message}`);
      }
    };

    window.loadStream();
  </script>
</body>
</html>
